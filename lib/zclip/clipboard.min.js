/ *！
 *剪贴板.js v2.0.6
 * https://clipboardjs.com/
 * 
 *麻省理工学院©Zeno Rocha
 * /
（函数webpackUniversalModuleDefinition（root，factory）{
	if（typeof出口==='对象'&& typeof模块==='对象'）
		module.exports = factory（）;
	否则if（typeof define ==='function'&& define.amd）
		define（[]，factory）;
	否则if（typeof输出==='对象'）
		exports [“ ClipboardJS”] = factory（）;
	其他
		root [“ ClipboardJS”] = factory（）;
}）（this，function（）{
return / ****** /（function（modules）{// webpackBootstrap
/ ****** / //模块缓存
/ ****** / var installedModules = {};
/ ****** /
/ ****** / // require函数
/ ****** /函数__webpack_require __（moduleId）{
/ ****** /
/ ****** / //检查模块是否在缓存中
/ ****** / if（installedModules [moduleId]）{
/ ****** /返回installedModules [moduleId] .exports;
/ ****** /}
/ ****** / //创建一个新模块（并将其放入缓存）
/ ****** / var module = installedModules [moduleId] = {
/ ****** / i：moduleId，
/ ****** / l：否，
/ ****** /出口：{}
/ ****** /};
/ ****** /
/ ****** / //执行模块功能
/ ****** / modules [moduleId] .call（module.exports，module，module.exports，__ webpack_require__）;
/ ****** /
/ ****** / //将模块标记为已加载
/ ****** / module.l = true;
/ ****** /
/ ****** / //返回模块的导出
/ ****** /返回module.exports;
/ ****** /}
/ ****** /
/ ****** /
/ ****** / //公开模块对象（__webpack_modules__）
/ ****** / __webpack_require __。m =模块；
/ ****** /
/ ****** / //公开模块缓存
/ ****** / __webpack_require __。c = installedModules;
/ ****** /
/ ****** / //为和谐输出定义getter函数
/ ****** / __webpack_require __。d = function（exports，name，getter）{
/ ****** / if（！__ webpack_require __。o（出口，名称））{
/ ****** / Object.defineProperty（exports，name，{枚举：true，get：getter}）;
/ ****** /}
/ ****** /};
/ ****** /
/ ****** / //在导出中定义__esModule
/ ****** / __webpack_require __。r =函数（导出）{
/ ****** / if（typeof Symbol！=='undefined'&& Symbol.toStringTag）{
/ ****** / Object.defineProperty（exports，Symbol.toStringTag，{value：'Module'}）;
/ ****** /}
/ ****** / Object.defineProperty（exports，'__esModule'，{value：true}）;
/ ****** /};
/ ****** /
/ ****** / //创建一个假的名称空间对象
/ ****** / //模式＆1：值是模块ID，需要它
/ ****** / //模式＆2：将value的所有属性合并到ns中
/ ****** / //模式＆4：当已为ns对象时返回值
/ ****** / //模式＆8 | 1：表现为require
/ ****** / __webpack_require __。t =函数（值，模式）{
/ ****** / if（mode＆1）value = __webpack_require __（value）;
/ ****** / if（mode＆8）返回值;
/ ****** / if（（mode＆4）&& typeof value ==='object'&& value && value .__ esModule）返回值；
/ ****** / var ns = Object.create（null）;
/ ****** / __webpack_require __。r（ns）;
/ ****** / Object.defineProperty（ns，'default'，{可枚举：true，值：value}）;
/ ****** / if（mode＆2 && typeof value！='string'）for（var key in value）__webpack_require __。d（ns，key，function（key）{return value [key];}。 bind（null，key））;
/ ****** /返回ns;
/ ****** /};
/ ****** /
/ ****** / // getDefaultExport函数与非谐波模块兼容
/ ****** / __webpack_require __。n =函数（模块）{
/ ****** / var getter =模块&&模块.__ esModule？
/ ****** / function getDefault（）{return module ['default']; }：
/ ****** / function getModuleExports（）{返回模块；};
/ ****** / __webpack_require __。d（getter，'a'，getter）;
/ ****** /返回getter；
/ ****** /};
/ ****** /
/ ****** / // Object.prototype.hasOwnProperty.call
/ ****** / __webpack_require __。o = function（object，property）{return Object.prototype.hasOwnProperty.call（object，property）; };
/ ****** /
/ ****** / // __webpack_public_path__
/ ****** / __webpack_require __。p =“”;
/ ****** /
/ ****** /
/ ****** / //加载输入模块并返回导出
/ ****** /返回__webpack_require __（__ webpack_require __。s = 6）;
/ ****** /}）
/ ***************************************************** *********************** /
/ ****** /（[
/ * 0 * /
/ *** /（函数（模块，导出）{

函数select（element）{
    var selectedText;

    如果（element.nodeName ==='SELECT'）{
        element.focus（）;

        selectedText = element.value;
    }
    否则if（element.nodeName ==='INPUT'|| element.nodeName ==='TEXTAREA'）{
        var isReadOnly = element.hasAttribute（'readonly'）;

        如果（！isReadOnly）{
            element.setAttribute（'readonly'，''）;
        }

        element.select（）;
        element.setSelectionRange（0，element.value.length）;

        如果（！isReadOnly）{
            element.removeAttribute（'readonly'）;
        }

        selectedText = element.value;
    }
    其他{
        如果（element.hasAttribute（'contenteditable'））{
            element.focus（）;
        }

        var selection = window.getSelection（）;
        var range = document.createRange（）;

        range.selectNodeContents（element）;
        selection.removeAllRanges（）;
        selection.addRange（range）;

        selectedText = selection.toString（）;
    }

    返回selectedText;
}

module.exports =选择;


/ *** /}），
/ * 1 * /
/ *** /（函数（模块，导出）{

函数E（）{
  //将其保留为空，以便从中继承
  //（通过https://github.com/scottcorgan/tiny-emitter/issues/3通过https://github.com/lipsmack）
}

E.prototype = {
  on：函数（名称，回调，ctx）{
    var e = this.e || （this.e = {}）；

    （e [name] ||（e [name] = []）））。push（{
      fn：回调，
      ctx：ctx
    }）;

    返回这个
  }，

  一次：函数（名称，回调，ctx）{
    var self = this;
    函数监听器（）{
      self.off（名字，监听者）;
      callback.apply（ctx，arguments）;
    };

    listener._ =回调
    返回this.on（name，listener，ctx）;
  }，

  发出：函数（​​名称）{
    var data = [] .slice.call（arguments，1）;
    var evtArr =（（this.e ||（this.e = {}））[名称] || []）。slice（）;
    var i = 0;
    var len = evtArr.length;

    为（i; i <len; i ++）{
      evtArr [i] .fn.apply（evtArr [i] .ctx，data）;
    }

    返回这个
  }，

  off：函数（名称，回调）{
    var e = this.e || （this.e = {}）；
    var evts = e [name];
    var liveEvents = [];

    如果（evts &&回调）{
      对于（var i = 0，len = evts.length; i <len; i ++）{
        if（evts [i] .fn！==回调&& evts [i] .fn._！==回调）
          liveEvents.push（evts [i]）;
      }
    }

    //从队列中删除事件以防止内存泄漏
    //由https://github.com/lazd建议
    //参考：https://github.com/scottcorgan/tiny-emitter/commit/c6ebfaa9bc973b33d110a84a307742b7cf94c953#commitcomment-5024910

    （liveEvents.length）
      ？e [name] = liveEvents
      ：删除e [name];

    返回这个
  }
};

module.exports = E;
module.exports.TinyEmitter = E;


/ *** /}），
/ * 2 * /
/ *** /（函数（模块，导出，__ webpack_require __）{

var is = __webpack_require __（3）;
var委托= __webpack_require __（4）;

/ **
 *验证所有参数并调用正确的
 *侦听器功能基于其目标类型。
 *
 * @param {String | HTMLElement | HTMLCollection | NodeList}目标
 * @param {String}类型
 * @param {Function}回调
 * @return {对象}
 * /
函数listen（target，type，callback）{
    if（！target &&！type &&！callback）{
        抛出新的错误（'缺少必需的参数'）;
    }

    如果（！is.string（type））{
        抛出新的TypeError（'第二个参数必须是字符串'）;
    }

    如果（！is.fn（回调））{
        抛出新的TypeError（'第三参数必须是一个函数'）;
    }

    如果（is.node（target））{
        返回listenNode（target，type，callback）;
    }
    否则if（is.nodeList（target））{
        返回listenNodeList（target，type，callback）;
    }
    否则if（is.string（target））{
        返回listenSelector（target，type，callback）;
    }
    其他{
        抛出新的TypeError（'第一个参数必须是String，HTMLElement，HTMLCollection或NodeList'）;
    }
}

/ **
 *将事件侦听器添加到HTML元素
 *并返回删除监听器函数。
 *
 * @param {HTMLElement}节点
 * @param {String}类型
 * @param {Function}回调
 * @return {对象}
 * /
函数listenNode（node，type，callback）{
    node.addEventListener（type，callback）;

    返回{
        销毁：function（）{
            node.removeEventListener（type，callback）;
        }
    }
}

/ **
 *将事件监听器添加到HTML元素列表中
 *并返回删除监听器函数。
 *
 * @param {NodeList | HTMLCollection} nodeList
 * @param {String}类型
 * @param {Function}回调
 * @return {对象}
 * /
函数listenNodeList（nodeList，type，callback）{
    Array.prototype.forEach.call（nodeList，function（node）{
        node.addEventListener（type，callback）;
    }）;

    返回{
        销毁：function（）{
            Array.prototype.forEach.call（nodeList，function（node）{
                node.removeEventListener（type，callback）;
            }）;
        }
    }
}

/ **
 *将事件监听器添加到选择器
 *并返回删除监听器函数。
 *
 * @param {String}选择器
 * @param {String}类型
 * @param {Function}回调
 * @return {对象}
 * /
function listenSelector（selector，type，callback）{
    返回委托（document.body，选择器，类型，回调）；
}

module.exports =听;


/ *** /}），
/ * 3 * /
/ *** /（函数（模块，导出）{

/ **
 *检查参数是否为HTML元素。
 *
 * @param {Object}值
 * @return {布尔}
 * /
Exports.node =函数（值）{
    返回值！==未定义
        &&值HTMLElement的实例
        && value.nodeType === 1;
};

/ **
 *检查参数是否为HTML元素列表。
 *
 * @param {Object}值
 * @return {布尔}
 * /
Exports.nodeList = function（value）{
    var type = Object.prototype.toString.call（value）;

    返回值！==未定义
        &&（类型==='[对象NodeList]'||类型==='[对象HTMLCollection]'）
        &&（值的“长度”）
        &&（value.length === 0 || exports.node（value [0]））;;
};

/ **
 *检查参数是否为字符串。
 *
 * @param {Object}值
 * @return {布尔}
 * /
Exports.string =函数（值）{
    返回typeof值==='字符串'
        || 值instanceof String;
};

/ **
 *检查参数是否为函数。
 *
 * @param {Object}值
 * @return {布尔}
 * /
Exports.fn =函数（值）{
    var type = Object.prototype.toString.call（value）;

    返回类型==='[对象功能]';
};


/ *** /}），
/ * 4 * /
/ *** /（函数（模块，导出，__ webpack_require __）{

var最近= __webpack_require __（5）;

/ **
 *将事件委托给选择器。
 *
 * @param {Element}元素
 * @param {String}选择器
 * @param {String}类型
 * @param {Function}回调
 * @param {Boolean} useCapture
 * @return {对象}
 * /
函数_delegate（元素，选择器，类型，回调，useCapture）{
    var listenerFn = listener.apply（this，arguments）;

    element.addEventListener（type，listenerFn，useCapture）;

    返回{
        销毁：function（）{
            element.removeEventListener（type，listenerFn，useCapture）;
        }
    }
}

/ **
 *将事件委托给选择器。
 *
 * @param {Element | String | Array} [元素]
 * @param {String}选择器
 * @param {String}类型
 * @param {Function}回调
 * @param {Boolean} useCapture
 * @return {对象}
 * /
函数委托（元素，选择器，类型，回调，useCapture）{
    //处理常规的Element用法
    如果（typeof elements.addEventListener ==='function'）{
        返回_delegate.apply（null，arguments）;
    }

    //处理无元素用法，默认为全局委托
    如果（typeof type ==='function'）{
        //使用`document`作为第一个参数，然后应用参数
        //这是.unshift`arguments`的一种简短方法，而不会遇到非优化
        返回_delegate.bind（null，document）.apply（null，arguments）;
    }

    //处理基于选择器的用法
    if（typeof elements ==='字符串'）{
        elements = document.querySelectorAll（elements）;
    }

    //处理类似数组的用法
    return Array.prototype.map.call（elements，function（element）{
        返回_delegate（元素，选择器，类型，回调，useCapture）;
    }）;
}

/ **
 *查找最接近的匹配项并调用回调。
 *
 * @param {Element}元素
 * @param {String}选择器
 * @param {String}类型
 * @param {Function}回调
 * @return {功能}
 * /
函数监听器（元素，选择器，类型，回调）{
    返回函数（e）{
        e.delegateTarget =最近的（e.target，选择器）;

        如果（e.delegateTarget）{
            callback.call（e，e）;
        }
    }
}

module.exports =委托;


/ *** /}），
/ * 5 * /
/ *** /（函数（模块，导出）{

var DOCUMENT_NODE_TYPE = 9;

/ **
 * Element.matches（）的polyfill
 * /
if（typeof Element！=='undefined'&&！Element.prototype.matches）{
    var proto = Element.prototype;

    proto.matches = proto.matchesSelector ||
                    proto.mozMatchesSelector ||
                    proto.msMatchesSelector ||
                    proto.oMatchesSelector ||
                    proto.webkitMatchesSelector;
}

/ **
 *查找与选择器匹配的最接近的父级。
 *
 * @param {Element}元素
 * @param {String}选择器
 * @return {功能}
 * /
最接近的函数（元素，选择器）{
    while（element && element.nodeType！== DOCUMENT_NODE_TYPE）{
        如果（typeof element.matches ==='function'&&
            element.matches（selector））{
          返回元素；
        }
        元素= element.parentNode;
    }
}

module.exports =最近的；


/ *** /}），
/ * 6 * /
/ *** /（函数（模块，__webpack_exports__，__webpack_require__）{

“使用严格”；
__webpack_require __。r（__ webpack_exports__）;

//外部模块：./ node_modules / select / src / select.js
var src_select = __webpack_require __（0）;
var select_default = /*#__PURE__*/__webpack_require__.n(src_select）;

//并置的模块：./ src / clipboard-action.js
var _typeof = typeof Symbol ===“ function” && typeof Symbol.iterator ===“ symbol”吗？函数（obj）{返回obj的typeof; }：函数（obj）{返回obj && typeof Symbol ===“ function” && obj.constructor === Symbol && obj！== Symbol.prototype吗？“ symbol”：typeof obj; };

var _createClass = function（）{function defineProperties（target，props）{for（var i = 0; i <props.length; i ++）{var描述符= props [i]; descriptor.enumerable =描述符.enumerable || 假; descriptor.configurable = true; if（描述符中的“值”）descriptor.writable = true; Object.defineProperty（target，descriptor.key，descriptor）; }}返回函数（构造函数，protoProps，staticProps）{如果（protoProps）defineProperties（Constructor.prototype，protoProps）; 如果（staticProps）defineProperties（Constructor，staticProps）; 返回构造函数；}; }（）;

函数_classCallCheck（instance，Constructor）{if（！（instance instanceof Constructor））{抛出新的TypeError（“不能将类作为函数调用”）; }}



/ **
 *内部类，可以从“文本”或“目标”中进行选择
 *属性，然后执行复制或剪切操作。
 * /

var剪贴板_action_ClipboardAction = function（）{
    / **
     * @param {Object}选项
     * /
    函数ClipboardAction（options）{
        _classCallCheck（this，ClipboardAction）;

        this.resolveOptions（options）;
        this.initSelection（）;
    }

    / **
     *定义从构造函数传递的基本属性。
     * @param {Object}选项
     * /


    _createClass（ClipboardAction，[{
        键：“ resolveOptions”，
        值：函数resolveOptions（）{
            var options = arguments.length> 0 && arguments [0]！==未定义？arguments [0]：{};

            this.action = options.action;
            this.container = options.container;
            this.emitter = options.emitter;
            this.target = options.target;
            this.text = options.text;
            this.trigger = options.trigger;

            this.selectedText ='';
        }

        / **
         *确定将基于哪种选择策略
         *关于“文本”和“目标”属性的存在。
         * /

    }，{
        键：“ initSelection”，
        值：函数initSelection（）{
            如果（this.text）{
                this.selectFake（）;
            }否则，如果（this.target）{
                this.selectTarget（）;
            }
        }

        / **
         *创建一个伪造的textarea元素，通过`text`属性设置其值，
         *并对其进行选择。
         * /

    }，{
        键：“ selectFake”，
        值：函数selectFake（）{
            var _this = this;

            var isRTL = document.documentElement.getAttribute（'dir'）=='rtl';

            this.removeFake（）;

            this.fakeHandlerCallback = function（）{
                返回_this.removeFake（）;
            };
            this.fakeHandler = this.container.addEventListener（'click'，this.fakeHandlerCallback）|| 真正;

            this.fakeElem = document.createElement（'textarea'）;
            //防止在iOS上缩放
            this.fakeElem.style.fontSize ='12pt';
            //重置盒子模型
            this.fakeElem.style.border ='0';
            this.fakeElem.style.padding ='0';
            this.fakeElem.style.margin ='0';
            //将元素水平移出屏幕
            this.fakeElem.style.position ='绝对';
            this.fakeElem.style [isRTL吗？'right'：'left'] ='-9999px';
            //将元素垂直移动到相同位置
            var yPosition = window.pageYOffset || document.documentElement.scrollTop;
            this.fakeElem.style.top = yPosition +'px';

            this.fakeElem.setAttribute（'readonly'，''）;
            this.fakeElem.value = this.text;

            this.container.appendChild（this.fakeElem）;

            this.selectedText = select_default（）（this.fakeElem）;
            this.copyText（）;
        }

        / **
         *这样只会在另一个点击事件之后删除假元素
         *因为选择仍然存在，所以用户可以按“ Ctrl + C”进行复制。
         * /

    }，{
        密钥：“ removeFake”，
        值：函数removeFake（）{
            如果（this.fakeHandler）{
                this.container.removeEventListener（'click'，this.fakeHandlerCallback）;
                this.fakeHandler = null;
                this.fakeHandlerCallback = null;
            }

            如果（this.fakeElem）{
                this.container.removeChild（this.fakeElem）;
                this.fakeElem = null;
            }
        }

        / **
         *从传递给`target`属性的元素中选择内容。
         * /

    }，{
        键：“ selectTarget”，
        值：函数selectTarget（）{
            this.selectedText = select_default（）（this.target）;
            this.copyText（）;
        }

        / **
         *根据当前选择执行复制操作。
         * /

    }，{
        键：“ copyText”，
        值：函数copyText（）{
            var成功=无效0;

            尝试{
                成功= document.execCommand（this.action）;
            } catch（err）{
                成功=假；
            }

            this.handleResult（成功）;
        }

        / **
         *根据复制操作结果触发事件。
         * @param {布尔}成功
         * /

    }，{
        键：“ handleResult”，
        值：函数handleResult（成功）{
            this.emitter.emit（成功？“成功”：“错误”，{
                动作：this.action，
                文字：this.selectedText，
                触发：this.trigger，
                clearSelection：this.clearSelection.bind（this）
            }）;
        }

        / **
         *将焦点从“目标”移开并返回到触发器，从而删除当前选择。
         * /

    }，{
        关键：“ clearSelection”，
        值：函数clearSelection（）{
            如果（this.trigger）{
                this.trigger.focus（）;
            }
            document.activeElement.blur（）;
            window.getSelection（）。removeAllRanges（）;
        }

        / **
         *设置要执行的“动作”，可以是“复制”或“剪切”。
         * @param {String}操作
         * /

    }，{
        关键：“破坏”，


        / **
         *破坏生命周期。
         * /
        值：函数destroy（）{
            this.removeFake（）;
        }
    }，{
        关键：“行动”，
        设置：函数set（）{
            var action = arguments.length> 0 && arguments [0]！==未定义？arguments [0]：'复制';

            this._action =操作；

            如果（this._action！=='copy'&& this._action！=='cut'）{
                抛出新的错误（“无效的“动作”值，使用“复制”或“剪切”'）；
            }
        }

        / **
         *获取`action`属性。
         * @return {String}
         * /
        ，
        get：function get（）{
            返回this._action;
        }

        / **
         *使用元素设置`target`属性
         *将复制其内容。
         * @param {Element}目标
         * /

    }，{
        键：“目标”，
        设置：功能集（目标）{
            如果（目标！==未定义）{
                if（target &&（typeof target ==='undefined'？'undefined'：_typeof（target））==='object'&& target.nodeType === 1）{
                    如果（this.action ==='copy'&& target.hasAttribute（'disabled'））{
                        抛出新的错误（“无效的“目标”属性。请使用“只读”而不是“禁用”属性'）；
                    }

                    如果（this.action ==='cut'&&（target.hasAttribute（'readonly'）|| target.hasAttribute（'disabled'）））{
                        抛出新的错误（“无效的“目标”属性。您无法从具有“只读”或“禁用”属性的元素中剪切文本”）；
                    }

                    this._target =目标；
                }其他{
                    抛出新的错误（“无效的“目标”值，使用有效的元素”）；
                }
            }
        }

        / **
         *获取`target`属性。
         * @return {String | HTMLElement}
         * /
        ，
        get：function get（）{
            返回this._target;
        }
    }]）;

    返回ClipboardAction;
}（）;

/ *和声默认导出* / var剪贴板_action =（clipboard_action_ClipboardAction）;
//外部模块：./ node_modules / tiny-emitter / index.js
var tiny_emitter = __webpack_require __（1）;
var tiny_emitter_default = /*#__PURE__*/__webpack_require__.n(tiny_emitter）;

//外部模块：./ node_modules / good-listener / src / listen.js
var listen = __webpack_require __（2）;
var listen_default = / *＃__ PURE __ * / __ webpack_require __。n（听）;

//并置的模块：./ src / clipboard.js
var剪贴板_typeof = typeof符号===“函数” && typeof Symbol.iterator ===“符号”？函数（obj）{返回obj的typeof; }：函数（obj）{返回obj && typeof Symbol ===“ function” && obj.constructor === Symbol && obj！== Symbol.prototype吗？“ symbol”：typeof obj; };

var剪贴板_createClass = function（）{function defineProperties（target，props）{for（var i = 0; i <props.length; i ++）{var描述符= props [i]; descriptor.enumerable =描述符.enumerable || 假; descriptor.configurable = true; if（描述符中的“值”）descriptor.writable = true; Object.defineProperty（target，descriptor.key，descriptor）; }}返回函数（构造函数，protoProps，staticProps）{如果（protoProps）defineProperties（Constructor.prototype，protoProps）; 如果（staticProps）defineProperties（Constructor，staticProps）; 返回构造函数；}; }（）;

函数剪贴板_classCallCheck（实例，构造函数）{如果（！（实例实例构造函数））{抛出新的TypeError（“不能将类作为函数调用”）; }}

函数_possibleConstructorReturn（self，call）{如果（！self）{抛出新的ReferenceError（“这尚未初始化-尚未调用super（）”）; }返回调用&&（typeof call ===“ object” || typeof call ===“ function”）？自我称呼 }

函数_inherits（subClass，superClass）{如果（typeof superClass！==“ function” && superClass！== null）{抛出new TypeError（“超级表达式必须为null或函数，而不是” + typeof superClass）；} subClass.prototype = Object.create（superClass && superClass.prototype，{构造函数：{值：subClass，可枚举：false，可写：true，可配置：true}}）；如果（superClass）Object.setPrototypeOf？Object.setPrototypeOf（subClass，superClass）：subClass .__ proto__ = superClass; }





/ **
 *基类，它接受一个或多个元素，向它们添加事件侦听器，
 *，并在每次点击时实例化一个新的“ ClipboardAction”。
 * /

var剪贴板_Clipboard =函数（_Emitter）{
    _inherits（剪贴板，_Emitter）;

    / **
     * @param {String | HTMLElement | HTMLCollection | NodeList}触发器
     * @param {Object}选项
     * /
    功能剪贴板（触发器，选项）{
        剪贴板_classCallCheck（this，剪贴板）;

        var _this = _possibleConstructorReturn（this，（Clipboard .__ proto__ || Object.getPrototypeOf（Clipboard））。call（this））;

        _this.resolveOptions（options）;
        _this.listenClick（trigger）;
        返回_this;
    }

    / **
     *定义是否使用内部setter函数解析属性
     *或在构造函数中传递的自定义函数。
     * @param {Object}选项
     * /


    剪贴板_createClass（剪贴板，[{
        键：“ resolveOptions”，
        值：函数resolveOptions（）{
            var options = arguments.length> 0 && arguments [0]！==未定义？arguments [0]：{};

            this.action = typeof options.action ==='function'吗？options.action：this.defaultAction;
            this.target = typeof options.target ==='功能'吗？options.target：this.defaultTarget;
            this.text = typeof options.text ==='功能'吗？options.text：this.defaultText;
            this.container =剪贴板_typeof（options.container）==='对象'？options.container：document.body;
        }

        / **
         *将click事件监听器添加到传递的触发器中。
         * @param {String | HTMLElement | HTMLCollection | NodeList}触发器
         * /

    }，{
        键：“ listenClick”，
        值：函数listenClick（trigger）{
            var _this2 = this;

            this.listener = listen_default（）（trigger，'click'，function（e）{
                返回_this2.onClick（e）;
            }）;
        }

        / **
         *在每次点击事件中定义一个新的“ ClipboardAction”。
         * @param {Event} e
         * /

    }，{
        键：“ onClick”，
        值：函数onClick（e）{
            var trigger = e.delegateTarget || e.currentTarget;

            如果（this.clipboardAction）{
                this.clipboardAction = null;
            }

            this.clipboardAction =新的剪贴板动作（{
                动作：this.action（trigger），
                目标：this.target（trigger），
                文字：this.text（trigger），
                容器：this.container，
                触发：触发，
                发射器：这个
            }）;
        }

        / **
         *默认的“动作”查找功能。
         * @param {Element}触发器
         * /

    }，{
        键：“ defaultAction”，
        值：函数defaultAction（trigger）{
            返回getAttributeValue（'action'，触发器）;
        }

        / **
         *默认的“目标”查找功能。
         * @param {Element}触发器
         * /

    }，{
        键：“ defaultTarget”，
        值：函数defaultTarget（trigger）{
            var selector = getAttributeValue（'target'，trigger）;

            如果（选择器）{
                返回document.querySelector（selector）;
            }
        }

        / **
         *返回给定动作的支持，如果没有动作则返回所有动作
         *给出。
         * @param {String} [操作]
         * /

    }，{
        键：“ defaultText”，


        / **
         *默认的“文本”查找功能。
         * @param {Element}触发器
         * /
        值：函数defaultText（trigger）{
            返回getAttributeValue（'text'，trigger）;
        }

        / **
         *破坏生命周期。
         * /

    }，{
        关键：“破坏”，
        值：函数destroy（）{
            this.listener.destroy（）;

            如果（this.clipboardAction）{
                this.clipboardAction.destroy（）;
                this.clipboardAction = null;
            }
        }
    }]，[{
        密钥：“ isSupported”，
        值：函数isSupported（）{
            var action = arguments.length> 0 && arguments [0]！==未定义？arguments [0]：['copy'，'cut'];

            var actions = typeof action ==='string'吗？[动作]：动作；
            var support = !! document.queryCommandSupported;

            actions.forEach（function（action）{
                支持=支持&& !! document.queryCommandSupported（action）;
            }）;

            返回支持；
        }
    }]）;

    返回剪贴板；
}（tiny_emitter_default.a）;

/ **
 * Helper函数检索属性值。
 * @param {String}后缀
 * @param {Element}元素
 * /


函数getAttributeValue（后缀，元素）{
    var attribute ='data-clipboard-'+后缀；

    如果（！element.hasAttribute（attribute））{
        返回;
    }

    返回element.getAttribute（attribute）;
}

/ *和谐默认导出* / var剪贴板= __webpack_exports __ [“默认”] =（clipboard_Clipboard）;

/ *** /}）
/ ****** /]）[“默认”];
}）;